# Kotlin 泛型

泛型，这个概念在很多编程语言里面都存在。在中大型软件开发当中，我们对泛型的使用也十分频繁，因为它可以让我们在不同类型之间复用相似的逻辑代码。

另外，我们在定义泛型的时候，其实还可以为它的泛型参数增加一些边界限制，比如说，强制要求传入的泛型参数，必须是 TV 或者是它的子类。这叫做泛型的上界。

```kotlin
//               差别在这里
//                   ↓
class Controller<T: TV> {
    fun turnOn(tv: T) {}
    fun turnOff(tv: T) {}
}
```

## 型变

简单来说，它就是为了解决泛型的不变性问题。事实上，型变讨论的是：在已知 Cat 是 Animal 的子类的情况下，MutableList<Cat>与MutableList<Animal>之间是什么关系。

所以，在默认情况下，编译器会认为MutableList<Cat>与MutableList<Animal>之间不存在任何继承关系，它们也无法互相替代，这样就不会出现前面提到的两种问题。这就是泛型的不变性。

但是啊，在某些特定场景下，编译器这种行为还是会给我们带来麻烦的。而这个时候，就需要泛型的逆变与协变了。

### 逆变（Contravariant）

关键字：in。

“万能遥控”成了“小米遥控”的子类。这种父子关系颠倒的现象，我们就叫做“泛型的逆变”。上面这两种修改方式，就分别叫做使用处逆变和声明处逆变。

### 协变（Covariant）

关键字：out。

需要特别注意的是，虽然 Java 当中也有型变的概念，但是呢，Java 当中是没有声明处型变的。Java 里面只有使用处型变，下面是它们的语法对比：

![](https://blog-pic-1251295613.cos.ap-guangzhou.myqcloud.com/1692802159.6509628SmartPic.png)

### 星投影（Star-Projections）

所谓的星投影，其实就是用“星号”作为泛型的实参。

到底什么时候用逆变，什么时候用协变？如果你看过 Kotlin 的官方文档，你会看到一句这样的话：Consumer in, Producer out !

消费者 in，生产者 out。